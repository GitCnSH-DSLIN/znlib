           
// =========================================================================
// A kbmMemTable based SQL implementation.
//
// Copyright 2007-2015 Kim Bo Madsen/Components4Developers DK
// All rights reserved.
//
// Before using this file you must have read, understood and accepted the
// the license agreement which you find in the file license.txt.
// If that file is not part of the package then the package is not valid and
// must be removed immediately. A valid package can be downloaded from
// Components4Developers at www.components4developers.com


{ This unit was generated by DCocoR.  
  Any code in this file that you edit manually will be over-written when the file is regenerated.
}

unit kbmSQLParser;

interface

              
{$include kbmMemTable.inc}

{$IFDEF LEVEL18}
 {$ZEROBASEDSTRINGS OFF}
{$ENDIF}



uses Classes,CocoAncestor,
          kbmSQLElements, Variants, DB, SysUtils ;

type


  TkbmSQLParserScanner = class(TCocoRScanner)
  public
    procedure SkipIgnoreSet; override;
    procedure ScanSym(state: Integer; var sym: Integer); override;
    function SkipComments(ind: Integer): Boolean; override;
  end;


  TkbmSQLParser = class(TCocoRGrammar)
  private             
    FSubSelectDepth : integer;
//    FInNaturalJoin : boolean;

    FOperation:TkbmSQLCustomOperation;
    FExpressionOptions:TkbmSQLExpressionOptions;

    FContext:TObject;
    FOnGetVariableMetaData:TkbmSQLOnGetVariableMetaData;
    FOnGetVariableValue:TkbmSQLOnGetVariableValue;
    FOnGetFunction:TkbmSQLOnGetFunction;

    function UnQuoteSQLString(const AString:string):string;
    function UnQuoteIdentifier(const AString:string):string;
    function AppendBinaryNode(AOperation:TkbmSQLCustomOperation; const AOperator:TkbmSQLBinaryNodeOperator; ALeftNode:TkbmSQLCustomNode; ARightNode:TkbmSQLCustomNode):TkbmSQLCustomNode;

    property SubSelectDepth : integer read FSubSelectDepth write FSubSelectDepth;
//    property InNaturalJoin : boolean read FInNaturalJoin write FInNaturalJoin;

  protected

    procedure _kbmSQLParser;
    procedure _SelectSQL(var statement:TkbmSQLSelectOperation);
    procedure _UpdateSQL(var statement:TkbmSQLUpdateOperation);
    procedure _InsertSQL(var statement:TkbmSQLInsertOperation);
    procedure _DeleteSQL(var statement:TkbmSQLDeleteOperation);
    procedure _Evaluate(var statement:TkbmSQLEvaluationOperation);
    procedure _SelectStmt(statement:TkbmSQLSelectOperation);
    procedure _UpdateStmt(statement:TkbmSQLUpdateOperation);
    procedure _InsertStmt(statement:TkbmSQLInsertOperation);
    procedure _DeleteStmt(statement:TkbmSQLDeleteOperation);
    procedure _EvaluateStmt(statement:TkbmSQLEvaluationOperation);
    procedure _FilterStmt(statement:TkbmSQLEvaluationOperation);
    procedure _UnqualifiedTable(var table:TkbmSQLTable);
    procedure _UpdateFieldList(statement:TkbmSQLUpdateOperation);
    procedure _WhereClause(var condition:TkbmSQLCustomNode);
    procedure _UpdateField(statement:TkbmSQLUpdateOperation);
    procedure _QualifiedField(var node:TkbmSQLFieldNode);
    procedure _Expression(var node:TkbmSQLCustomNode);
    procedure _ItemSeparator;
    procedure _OpenParens;
    procedure _InsertFieldList(fields:TkbmSQLFieldNodes);
    procedure _CloseParens;
    procedure _ExpressionList(nodes:TkbmSQLNodes);
    procedure _SelectionClause(statement:TkbmSQLSelectOperation);
    procedure _FromClause(statement:TkbmSQLSelectOperation);
    procedure _GroupByClause(statement:TkbmSQLSelectOperation);
    procedure _HavingClause(var condition:TkbmSQLCustomNode);
    procedure _OrderByClause(statement:TkbmSQLSelectOperation);
    procedure _LimitClause(statement:TkbmSQLSelectOperation);
    procedure _OffsetClause(statement:TkbmSQLSelectOperation);
    procedure _OutputClause(statement:TkbmSQLSelectOperation);
    procedure _SelectionFieldList(fields:TkbmSQLNodes);
    procedure _FromTableList(tables:TkbmSQLTables);
    procedure _Destination(operation:TkbmSQLSelectOperation);
    procedure _QualifiedTable(var table:TkbmSQLTable);
    procedure _Table(var table:TkbmSQLTable);
    procedure _SubSet(var subset:string);
    procedure _Source(table:TkbmSQLTable);
    procedure _SearchCondition(var condition:TkbmSQLCustomNode);
    procedure _OrderByFldList(statement:TkbmSQLSelectOperation);
    procedure _GroupByFldList(statement:TkbmSQLSelectOperation);
    procedure _MathTerm(var node:TkbmSQLCustomNode);
    procedure _SelectionExpr(var node:TkbmSQLCustomNode);
    procedure _FunctionExpr(var exprnode:TkbmSQLCustomNode);
    procedure _ConstExpr(var node:TkbmSQLCustomNode);
    procedure _Null;
    procedure _True;
    procedure _False;
    procedure _FieldExpr(var node:TkbmSQLCustomNode);
    procedure _Variable(var node:TkbmSQLVariableNode);
    procedure _SimpleVariable(var node:TkbmSQLVariableNode);
    procedure _VariableExpr(var node:TkbmSQLCustomNode);
    procedure _SimpleVariableExpr(var node:TkbmSQLCustomNode);
    procedure _OrderByField(var node:TkbmSQLFieldNode);
    procedure _GroupByField(var node:TkbmSQLFieldNode);
    procedure _AndOrTerm(var node:TkbmSQLCustomNode);
    procedure _BinaryExpression(var node:TkbmSQLCustomNode);
    procedure _Factor(var node:TkbmSQLCustomNode);
    procedure _Term(var node:TkbmSQLCustomNode);

  public
           
{$IFDEF LEVEL9}
    FormatSettings:TFormatSettings;
{$ENDIF}
    procedure Init;


    procedure ProcessPragmas; override;
    function  ErrorMessage(ErrorType,ErrorCode: Integer; const data: string): String; override;
    function  TokenToString(n: Integer): String; override;
    function  CreateScanner: TBaseScanner; override;
    function Execute: Boolean; override;

    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
                
    property Operation:TkbmSQLCustomOperation read FOperation write FOperation;
    property ExpressionOptions:TkbmSQLExpressionOptions read FExpressionOptions write FExpressionOptions;
    property Context:TObject read FContext write FContext;
    property OnGetVariableMetaData:TkbmSQLOnGetVariableMetaData read FOnGetVariableMetaData write FOnGetVariableMetaData;
    property OnGetVariableValue:TkbmSQLOnGetVariableValue read FOnGetVariableValue write FOnGetVariableValue;
    property OnGetFunction:TkbmSQLOnGetFunction read FOnGetFunction write FOnGetFunction;

  end;

implementation

const

	SQLStringSym = 1;	variableidentSym = 2;	identSym = 3;	funcidentSym = 4;	integer_Sym = 5;
	floatSym = 6;	_semicolonSym = 7;	UNIONSym = 8;	ALLSym = 9;	UPDATESym = 10;
	SETSym = 11;	_equalSym = 12;	INSERTSym = 13;	INTOSym = 14;	VALUESSym = 15;
	DELETESym = 16;	FROMSym = 17;	EVALSym = 18;	CALCSym = 19;	FILTERSym = 20;
	SELECTSym = 21;	DISTINCTSym = 22;	OUTPUTSym = 23;	ASSym = 24;	SUBSETSym = 25;
	WHERESym = 26;	HAVINGSym = 27;	ORDERSym = 28;	BYSym = 29;	GROUPSym = 30;
	LIMITSym = 31;	OFFSETSym = 32;	_lparenSym = 33;	_rparenSym = 34;	_starSym = 35;
	_pointSym = 36;	NULLSym = 37;	TRUESym = 38;	FALSESym = 39;	FILE_lparenSym = 40;
	TEXT_lparenSym = 41;	_commaSym = 42;	DESCSym = 43;	ASCSym = 44;	NOTSym = 45;
	ANDSym = 46;	ORSym = 47;	XORSym = 48;	_less_greaterSym = 49;	_lessSym = 50;
	_less_equalSym = 51;	_greaterSym = 52;	_greater_equalSym = 53;	INSym = 54;	LIKESym = 55;
	BETWEENSym = 56;	ISSym = 57;	_plusSym = 58;	_minusSym = 59;	_bar_barSym = 60;
	_slashSym = 61;	MODSym = 62;	DIVSym = 63;	_NOSYMB = 64;	_slash_starSym = 65;
	_slash_slashSym = 66;

var kbmSQLParserSymSets: TSetArray;


var
  kbmSQLParserST: TStartTable = nil;
  kbmSQLParserLiterals: TLiteralList = nil;

{ TkbmSQLParserScanner }

procedure TkbmSQLParserScanner.ScanSym(state: Integer; var sym: Integer);
begin
 while True do
 begin
  NextCh;
  case state of
	 1:
		if ((CurrInputCh>=' ')and(CurrInputCh<='&'))or(CurrInputCh>='(') then
		else if (CurrInputCh = '''') then
		  state := 13
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 2:
		if (CurrInputCh=' ')or(CurrInputCh='!')or(CurrInputCh>='#') then
		else if (CurrInputCh = '"') then
		  state := 14
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 3:
		if ((CurrInputCh>='A')and(CurrInputCh<='Z'))or(CurrInputCh='_')or((CurrInputCh>='a')and(CurrInputCh<='z')) then
		  state := 4
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 4:
		if (CurrInputCh='.')or((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='Z'))or(CurrInputCh='_')or((CurrInputCh>='a')and(CurrInputCh<='z')) then
		else begin
		  sym := variableidentSym;
		  Exit;
		end;
	 5:
		if ((CurrInputCh>=' ')and(CurrInputCh<='\'))or(CurrInputCh>='^') then
		else if (CurrInputCh = ']') then
		  state := 15
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 6:
		begin
		  sym := funcidentSym;
		  CheckLiteral(sym);
		  Exit;
		end;
	 7:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 8
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	 8:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else begin
		  sym := floatSym;
		  Exit;
		end;
	 9:
		begin
		  sym := _slash_starSym;
		  Exit;
		end;
	10:
		begin
		  sym := _slash_slashSym;
		  Exit;
		end;
	11:
		if ((CurrInputCh>='0')and(CurrInputCh<='9'))or((CurrInputCh>='A')and(CurrInputCh<='Z'))or(CurrInputCh='_')or((CurrInputCh>='a')and(CurrInputCh<='z')) then
		else if (CurrInputCh = '(') then
		  state := 6
		else begin
		  sym := identSym;
		  CheckLiteral(sym);
		  Exit;
		end;
	12:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		else if (CurrInputCh = '.') then
		  state := 7
		else begin
		  sym := integer_Sym;
		  Exit;
		end;
	13:
		if (CurrInputCh = '''') then
		  state := 1
		else begin
		  sym := SQLStringSym;
		  Exit;
		end;
	14:
		if (CurrInputCh = '"') then
		  state := 2
		else begin
		  sym := SQLStringSym;
		  Exit;
		end;
	15:
		if (CurrInputCh = ']') then
		  state := 5
		else begin
		  sym := identSym;
		  CheckLiteral(sym);
		  Exit;
		end;
	16:
		begin
		  sym := _semicolonSym;
		  Exit;
		end;
	17:
		begin
		  sym := _equalSym;
		  Exit;
		end;
	18:
		begin
		  sym := _lparenSym;
		  Exit;
		end;
	19:
		begin
		  sym := _rparenSym;
		  Exit;
		end;
	20:
		begin
		  sym := _starSym;
		  Exit;
		end;
	21:
		begin
		  sym := _commaSym;
		  Exit;
		end;
	22:
		begin
		  sym := _less_greaterSym;
		  Exit;
		end;
	23:
		begin
		  sym := _less_equalSym;
		  Exit;
		end;
	24:
		begin
		  sym := _greater_equalSym;
		  Exit;
		end;
	25:
		begin
		  sym := _plusSym;
		  Exit;
		end;
	26:
		begin
		  sym := _minusSym;
		  Exit;
		end;
	27:
		if (CurrInputCh = '|') then
		  state := 28
		else begin
		  sym := _NOSYMB;
		  Exit;
		end;
	28:
		begin
		  sym := _bar_barSym;
		  Exit;
		end;
	29:
		if ((CurrInputCh>='0')and(CurrInputCh<='9')) then
		  state := 8
		else begin
		  sym := _pointSym;
		  Exit;
		end;
	30:
		if (CurrInputCh = '*') then
		  state := 9
		else if (CurrInputCh = '/') then
		  state := 10
		else begin
		  sym := _slashSym;
		  Exit;
		end;
	31:
		if (CurrInputCh = '>') then
		  state := 22
		else if (CurrInputCh = '=') then
		  state := 23
		else begin
		  sym := _lessSym;
		  Exit;
		end;
	32:
		if (CurrInputCh = '=') then
		  state := 24
		else begin
		  sym := _greaterSym;
		  Exit;
		end;
  
    else begin
      if CurrInputCh=#0 then
           sym := _EOFSYMB
      else sym := _NOSYMB;
      Exit;
    end;
  end;
 end;
end;


procedure TkbmSQLParserScanner.SkipIgnoreSet;
begin
  while (CurrInputCh = ' ') or 
    ( (CurrInputCh=#9)or(CurrInputCh=#10)or(CurrInputCh=#13) )
  do NextCh;
end;


function TkbmSQLParserScanner.SkipComments(ind: Integer): Boolean;
begin
  Result := True;
  case ind of
    _slash_starSym: SkipNestedComment(#39'/*'#39,'*/');
    _slash_slashSym: SkipCommentTo(#13);

    else Result := False;
  end;
end;



{ TkbmSQLParser }

                   

procedure TkbmSQLParser.Init;
begin
  SubSelectDepth := 0;
  FreeAndNil(FOperation);
end;

function TkbmSQLParser.AppendBinaryNode(AOperation:TkbmSQLCustomOperation; const AOperator:TkbmSQLBinaryNodeOperator; ALeftNode:TkbmSQLCustomNode; ARightNode:TkbmSQLCustomNode):TkbmSQLCustomNode;
begin
     Result:=TkbmSQLBinaryNode.Create(AOperation,AOperator);
     TkbmSQLBinaryNode(Result).LeftNode:=ALeftNode;
     TkbmSQLBinaryNode(Result).RightNode:=ARightNode;
     if ALeftNode<>nil then
        TkbmSQLBinaryNode(Result).LeftNode.Parent:=Result;
     if ARightNode<>nil then
        TkbmSQLBinaryNode(Result).RightNode.Parent:=Result;
end;

function TkbmSQLParser.UnQuoteSQLString(const AString:string):string;
var
   ch:Char;
   i,l,n:nativeint;
   quoted:boolean;
begin
     // Calculate length of resultstring.
     l:=length(AString);
     if l<=0 then
     begin
          Result:='';
          exit;
     end;

     // Check if start quote.
     ch:=AString[1];
     SetLength(Result,l-2);
     quoted:=false;
     n:=1;
     for i:=2 to l-1 do
     begin
          if AString[i]=ch then
          begin
               if quoted then
               begin
                    Result[n]:=ch;
                    inc(n);
                    quoted:=false;
               end
               else
                   quoted:=true;
          end
          else
          begin
               Result[n]:=AString[i];
               inc(n);
          end;
     end;
     if quoted then
     begin
          Result:=AString;
          exit;
     end;
     SetLength(Result,n-1);
end;

function TkbmSQLParser.UnQuoteIdentifier(const AString:string):string;
var
   i,l,n:nativeint;
   quoted:boolean;
begin
     // Calculate length of resultstring.
     l:=length(AString);
     if l<=0 then
     begin
          Result:='';
          exit;
     end;

     // Check if start quote.
     if AString[1]<>'[' then
     begin
          Result:=AString;
          exit;
     end;
     if AString[l]<>']' then
     begin
          Result:=AString;
          exit;
     end;
     SetLength(Result,l-2);
     quoted:=false;
     n:=1;
     for i:=2 to l-1 do
     begin
          if AString[i]=']' then
          begin
               if quoted then
               begin
                    Result[n]:=']';
                    inc(n);
                    quoted:=false;
               end
               else
                   quoted:=true;
          end
          else
          begin
               Result[n]:=AString[i];
               inc(n);
          end;
     end;
     if quoted then
     begin
          Result:=AString;
          exit;
     end;
     SetLength(Result,n-1);
end;


procedure TkbmSQLParser._kbmSQLParser;
                                                 var sel:TkbmSQLSelectOperation;
                                                     upd:TkbmSQLUpdateOperation;
                                                     ins:TkbmSQLInsertOperation;
                                                     del:TkbmSQLDeleteOperation;
                                                     eval:TkbmSQLEvaluationOperation;
                                              
begin
  if (CurrentInputSymbol=SELECTSym) then
  begin
       _SelectSQL(sel);
                                                 FOperation:=sel; 
  end
  else if (CurrentInputSymbol=UPDATESym) then
  begin
       _UpdateSQL(upd);
                                                 FOperation:=upd; 
  end
  else if (CurrentInputSymbol=INSERTSym) then
  begin
       _InsertSQL(ins);
                                                 FOperation:=ins; 
  end
  else if (CurrentInputSymbol=DELETESym) then
  begin
       _DeleteSQL(del);
                                                 FOperation:=del; 
  end
  else if (CurrentInputSymbol in [EVALSym, CALCSym, FILTERSym]) then
  begin
       _Evaluate(eval);
                                                 FOperation:=eval; 
       if (CurrentInputSymbol=_semicolonSym) then
       begin
         Get;
       end;
       Expect(_EOFSYMB);
  end
  else SynError(1);
end;

procedure TkbmSQLParser._SelectSQL(var statement:TkbmSQLSelectOperation);
begin
                                               statement:=TkbmSQLSelectOperation.Create(Owner);
                                               FOperation:=statement;
{$IFDEF LEVEL9}
                                               FOperation.FormatSettings:=FormatSettings;
{$ENDIF}
                                               FOperation.Context:=Context;
                                               FOperation.OnGetVariableMetaData:=OnGetVariableMetaData;
                                               FOperation.OnGetVariableValue:=OnGetVariableValue;
                                               FOperation.OnGetFunction:=OnGetFunction;
                                            
  _SelectStmt(statement);
  while (CurrentInputSymbol=UNIONSym) do
  begin
    Get;
                                               if LexString = 'JOIN' then
                                                 SynError(211); 
    if (CurrentInputSymbol=ALLSym) then
    begin
      Get;
    end;
    _SelectStmt(statement);
  end;
end;

procedure TkbmSQLParser._UpdateSQL(var statement:TkbmSQLUpdateOperation);
begin
                                               statement:=TkbmSQLUpdateOperation.Create(Owner);
                                               FOperation:=statement;
{$IFDEF LEVEL9}
                                               FOperation.FormatSettings:=FormatSettings;
{$ENDIF}
                                               FOperation.Context:=Context;
                                               FOperation.OnGetVariableMetaData:=OnGetVariableMetaData;
                                               FOperation.OnGetVariableValue:=OnGetVariableValue;
                                               FOperation.OnGetFunction:=OnGetFunction;
                                            
  _UpdateStmt(statement);
end;

procedure TkbmSQLParser._InsertSQL(var statement:TkbmSQLInsertOperation);
begin
                                               statement:=TkbmSQLInsertOperation.Create(Owner);
                                               FOperation:=statement;
{$IFDEF LEVEL9}
                                               FOperation.FormatSettings:=FormatSettings;
{$ENDIF}
                                               FOperation.Context:=Context;
                                               FOperation.OnGetVariableMetaData:=OnGetVariableMetaData;
                                               FOperation.OnGetVariableValue:=OnGetVariableValue;
                                               FOperation.OnGetFunction:=OnGetFunction;
                                            
  _InsertStmt(statement);
end;

procedure TkbmSQLParser._DeleteSQL(var statement:TkbmSQLDeleteOperation);
begin
                                               statement:=TkbmSQLDeleteOperation.Create(Owner);
                                               FOperation:=statement;
{$IFDEF LEVEL9}
                                               FOperation.FormatSettings:=FormatSettings;
{$ENDIF}
                                               FOperation.Context:=Context;
                                               FOperation.OnGetVariableMetaData:=OnGetVariableMetaData;
                                               FOperation.OnGetVariableValue:=OnGetVariableValue;
                                               FOperation.OnGetFunction:=OnGetFunction;
                                            
  _DeleteStmt(statement);
end;

procedure TkbmSQLParser._Evaluate(var statement:TkbmSQLEvaluationOperation);
begin
                                               statement:=TkbmSQLEvaluationOperation.Create(Owner);
                                               FOperation:=statement;
{$IFDEF LEVEL9}
                                               FOperation.FormatSettings:=FormatSettings;
{$ENDIF}
                                               FOperation.Context:=Context;
                                               FOperation.OnGetVariableMetaData:=OnGetVariableMetaData;
                                               FOperation.OnGetVariableValue:=OnGetVariableValue;
                                               FOperation.OnGetFunction:=OnGetFunction;
                                            
  if (CurrentInputSymbol in [EVALSym, CALCSym]) then
  begin
       _EvaluateStmt(statement);
  end
  else if (CurrentInputSymbol=FILTERSym) then
  begin
       _FilterStmt(statement);
  end
  else SynError(2);
end;

procedure TkbmSQLParser._SelectStmt(statement:TkbmSQLSelectOperation);
                                                   var whereNode:TkbmSQLCustomNode;
                                                       havingNode:TkbmSQLCustomNode;
                                                
begin
  _SelectionClause(statement);
  _FromClause(statement);
  if (CurrentInputSymbol=WHERESym) then
  begin
    _WhereClause(whereNode);
                                                   statement.Condition:=whereNode; 
  end;
  if (CurrentInputSymbol=GROUPSym) then
  begin
    _GroupByClause(statement);
  end;
  if (CurrentInputSymbol=HAVINGSym) then
  begin
    _HavingClause(havingNode);
                                                  statement.HavingCondition:=havingNode; 
  end;
  if (CurrentInputSymbol=ORDERSym) then
  begin
    _OrderByClause(statement);
  end;
  if (CurrentInputSymbol=LIMITSym) then
  begin
    _LimitClause(statement);
  end;
  if (CurrentInputSymbol=OFFSETSym) then
  begin
    _OffsetClause(statement);
  end;
  if (CurrentInputSymbol=OUTPUTSym) then
  begin
    _OutputClause(statement);
  end;
end;

procedure TkbmSQLParser._UpdateStmt(statement:TkbmSQLUpdateOperation);
                                                  var node:TkbmSQLCustomNode;
                                                      table:TkbmSQLTable;
                                               
begin
  Expect(UPDATESym);
  _UnqualifiedTable(table);
                                                     statement.Table:=table; 
  Expect(SETSym);
  _UpdateFieldList(statement);
  if (CurrentInputSymbol=WHERESym) then
  begin
    _WhereClause(node);
                                                     statement.Condition:=node; 
  end;
end;

procedure TkbmSQLParser._InsertStmt(statement:TkbmSQLInsertOperation);
                                                   var table:TkbmSQLTable; 
begin
                                                   FOperation.ParseState:=sopsInsert; 
  Expect(INSERTSym);
  Expect(INTOSym);
  _UnqualifiedTable(table);
                                                   statement.Table:=table; 
  if (CurrentInputSymbol=_lparenSym) then
  begin
    _OpenParens;
    _InsertFieldList(statement.Fields);
    _CloseParens;
  end;
  Expect(VALUESSym);
  _OpenParens;
  _ExpressionList(statement.Values);
  _CloseParens;
                                                   FOperation.ParseState:=sopsDefault; 
end;

procedure TkbmSQLParser._DeleteStmt(statement:TkbmSQLDeleteOperation);
                                                   var node:TkbmSQLCustomNode;
                                                       table:TkbmSQLTable;
                                                
begin
  Expect(DELETESym);
  Expect(FROMSym);
  _UnqualifiedTable(table);
                                                   statement.Table:=table; 
  if (CurrentInputSymbol=WHERESym) then
  begin
    _WhereClause(node);
                                                   statement.Condition:=node; 
  end;
end;

procedure TkbmSQLParser._EvaluateStmt(statement:TkbmSQLEvaluationOperation);
                                                        var node:TkbmSQLCustomNode;
                                                
begin
                                                   FOperation.ParseState:=sopsEvaluation; 
  if (CurrentInputSymbol=EVALSym) then
  begin
       Get;
                                                   statement.Flags:=[]; 
  end
  else if (CurrentInputSymbol=CALCSym) then
  begin
       Get;
                                                   statement.Flags:=[sopfNoBooleanExpressions]; 
  end
  else SynError(3);
  _Expression(node);
                                                   statement.Evaluation:=node; 
end;

procedure TkbmSQLParser._FilterStmt(statement:TkbmSQLEvaluationOperation);
                                                      var node:TkbmSQLCustomNode;
                                                
begin
                                                   FOperation.ParseState:=sopsFilter; 
  Expect(FILTERSym);
                                                   statement.Flags:=[]; 
  _Expression(node);
                                                   statement.Evaluation:=node; 
end;

procedure TkbmSQLParser._UnqualifiedTable(var table:TkbmSQLTable);
                                               var subset:string; 
begin
  _Table(table);
                                               FOperation.RefSourceTables.AddUnique(table); 
  if (CurrentInputSymbol=SUBSETSym) then
  begin
    _SubSet(subset);
                                               table.SubSetExpression:=subset; 
  end;
end;

procedure TkbmSQLParser._UpdateFieldList(statement:TkbmSQLUpdateOperation);
begin
  _UpdateField(statement);
  while (CurrentInputSymbol=_commaSym) do
  begin
    _ItemSeparator;
    _UpdateField(statement);
  end;
end;

procedure TkbmSQLParser._WhereClause(var condition:TkbmSQLCustomNode);
begin
  while not (CurrentInputSymbol in [_EOFSYMB, WHERESym]) do
  begin SynError(4); Get; end;
  Expect(WHERESym);
  _SearchCondition(condition);
end;

procedure TkbmSQLParser._UpdateField(statement:TkbmSQLUpdateOperation);
                                                     var
                                                        fieldnode:TkbmSQLFieldNode;
                                                        expressionnode:TkbmSQLCustomNode;
                                                  
begin
                                                     FOperation.ParseState:=sopsUpdate; 
  _QualifiedField(fieldnode);
                                                     statement.Fields.Add(fieldnode);
                                                     statement.RefSourceFields.Add(fieldnode);
                                                  
  Expect(_equalSym);
  _Expression(expressionnode);
                                                     statement.Values.Add(expressionnode);
                                                     FOperation.ParseState:=sopsDefault;
                                                  
end;

procedure TkbmSQLParser._QualifiedField(var node:TkbmSQLFieldNode);
                                               var tn,fn:string; 
begin
                                               node:=TkbmSQLFieldNode.Create(FOperation);
                                               tn:='';
                                               fn:='';
                                             
  if (CurrentInputSymbol=_starSym) then
  begin
       Get;
                                               fn:='*';
                                            
  end
  else if (CurrentInputSymbol=identSym) then
  begin
       Get;
                                               tn:=UnQuoteIdentifier(LexString); 
  end
  else SynError(5);
  if (CurrentInputSymbol=_pointSym) then
  begin
    Get;
    if (CurrentInputSymbol=_starSym) then
    begin
         Get;
                                               node.Tablename:=tn;
                                               fn:='*';
                                            
    end
    else if (CurrentInputSymbol=identSym) then
    begin
         Get;
                                               fn:=UnQuoteIdentifier(LexString); 
    end
    else SynError(5);
  end;
                                               if fn='' then
                                               begin
                                                    fn:=tn;
                                                    tn:='';
                                               end;
                                               node.Tablename:=tn;
                                               node.FieldName:=fn;
                                               fn:=UpperCase(fn);
                                               if fn='ROWID' then
                                                  node.FieldType:=ntRowID
                                               else if fn='RECNO' then
                                                  node.FieldType:=ntRecNo
                                               else if fn='*' then
                                                  node.FieldType:=ntWildCard
                                               else
                                                  node.FieldType:=ntField;
                                            
end;

procedure TkbmSQLParser._Expression(var node:TkbmSQLCustomNode);
                                                  var nnode:TkbmSQLCustomNode; bNot:boolean; 
begin
                                                  node:=nil;
                                                  bNot:=false; 
  if (CurrentInputSymbol=NOTSym) then
  begin
    Get;
                                                 
                                                  if sopfNoBooleanExpressions in FOperation.Flags then
                                                     SynError(213)
                                                  else
                                                      bNot:=true;
                                               
  end;
  _AndOrTerm(node);
                                                  if bNot then
                                                  begin
                                                       nnode:=TkbmSQLUnaryNode.Create(FOperation,euNot);
                                                       TkbmSQLUnaryNode(nnode).RightNode:=node;
                                                       if TkbmSQLUnaryNode(nnode).RightNode<>nil then
                                                          TkbmSQLUnaryNode(nnode).RightNode.Parent:=nnode;
                                                       node:=nnode;
                                                       node.DataType:=ftBoolean;
                                                  end;
                                               
end;

procedure TkbmSQLParser._ItemSeparator;
begin
  ExpectWeak(_commaSym,0);
end;

procedure TkbmSQLParser._OpenParens;
begin
  Expect(_lparenSym);
end;

procedure TkbmSQLParser._InsertFieldList(fields:TkbmSQLFieldNodes);
                                                var node:TkbmSQLFieldNode; 
begin
  _QualifiedField(node);
                                              fields.Add(node);
                                              FOperation.RefSourceFields.Add(node);
                                           
  while (CurrentInputSymbol=_commaSym) do
  begin
    _ItemSeparator;
    _QualifiedField(node);
                                              fields.Add(node);
                                              FOperation.RefSourceFields.Add(node);
                                           
  end;
end;

procedure TkbmSQLParser._CloseParens;
begin
  ExpectWeak(_rparenSym,1);
end;

procedure TkbmSQLParser._ExpressionList(nodes:TkbmSQLNodes);
                                               var node:TkbmSQLCustomNode; 
begin
                                               node:=nil; 
  _Expression(node);
                                               if node<>nil then
                                                  nodes.Add(node);
                                               node:=nil;
                                            
  while (CurrentInputSymbol=_commaSym) do
  begin
    _ItemSeparator;
    _Expression(node);
                                               if node<>nil then
                                               nodes.Add(node);
                                               node:=nil;
                                            
  end;
end;

procedure TkbmSQLParser._SelectionClause(statement:TkbmSQLSelectOperation);
begin
  Expect(SELECTSym);
  if (CurrentInputSymbol in [ALLSym, DISTINCTSym]) then
  begin
    if (CurrentInputSymbol=DISTINCTSym) then
    begin
         Get;
                                                 statement.Distinct:=true; 
    end
    else if (CurrentInputSymbol=ALLSym) then
    begin
         Get;
    end
    ;
  end;
  _SelectionFieldList(statement.Selection);
end;

procedure TkbmSQLParser._FromClause(statement:TkbmSQLSelectOperation);
begin
  while not (CurrentInputSymbol in [_EOFSYMB, FROMSym]) do
  begin SynError(6); Get; end;
  Expect(FROMSym);
  _FromTableList(statement.tables);
end;

procedure TkbmSQLParser._GroupByClause(statement:TkbmSQLSelectOperation);
begin
  while not (CurrentInputSymbol in [_EOFSYMB, GROUPSym]) do
  begin SynError(7); Get; end;
  Expect(GROUPSym);
  Expect(BYSym);
  _GroupByFldList(statement);
end;

procedure TkbmSQLParser._HavingClause(var condition:TkbmSQLCustomNode);
begin
  while not (CurrentInputSymbol in [_EOFSYMB, HAVINGSym]) do
  begin SynError(8); Get; end;
  Expect(HAVINGSym);
                                                   FOperation.ParseState:=sopsHavingCondition; 
  _SearchCondition(condition);
                                                   FOperation.ParseState:=sopsDefault; 
end;

procedure TkbmSQLParser._OrderByClause(statement:TkbmSQLSelectOperation);
begin
  while not (CurrentInputSymbol in [_EOFSYMB, ORDERSym]) do
  begin SynError(9); Get; end;
  Expect(ORDERSym);
  Expect(BYSym);
  _OrderByFldList(statement);
end;

procedure TkbmSQLParser._LimitClause(statement:TkbmSQLSelectOperation);
                                                     var node:TkbmSQLCustomNode; 
begin
                                                     statement.Limit:=nil; 
  while not (CurrentInputSymbol in [_EOFSYMB, LIMITSym]) do
  begin SynError(10); Get; end;
  Expect(LIMITSym);
  _MathTerm(node);
                                                     statement.Limit:=node; 
end;

procedure TkbmSQLParser._OffsetClause(statement:TkbmSQLSelectOperation);
                                                     var node:TkbmSQLCustomNode; 
begin
                                                     statement.Offset:=nil; 
  while not (CurrentInputSymbol in [_EOFSYMB, OFFSETSym]) do
  begin SynError(11); Get; end;
  Expect(OFFSETSym);
  _MathTerm(node);
                                                     statement.Offset:=node; 
end;

procedure TkbmSQLParser._OutputClause(statement:TkbmSQLSelectOperation);
begin
  while not (CurrentInputSymbol in [_EOFSYMB, OUTPUTSym]) do
  begin SynError(12); Get; end;
  Expect(OUTPUTSym);
  _Destination(statement);
end;

procedure TkbmSQLParser._SelectionFieldList(fields:TkbmSQLNodes);
                                               var node:TkbmSQLCustomNode; 
begin
                                               FOperation.ParseState:=sopsSelection; 
  _SelectionExpr(node);
                                               fields.Add(node); 
  while (CurrentInputSymbol=_commaSym) do
  begin
    _ItemSeparator;
    _SelectionExpr(node);
                                               fields.Add(node); 
  end;
                                               FOperation.ParseState:=sopsDefault; 
end;

procedure TkbmSQLParser._FromTableList(tables:TkbmSQLTables);
                                                 var table:TkbmSQLTable; 
begin
  _QualifiedTable(table);
                                                 tables.Add(table); 
  while (CurrentInputSymbol=_commaSym) do
  begin
    _ItemSeparator;
    _QualifiedTable(table);
                                                 tables.Add(table); 
  end;
end;

procedure TkbmSQLParser._Destination(operation:TkbmSQLSelectOperation);
begin
  if (CurrentInputSymbol=TEXT_lparenSym) then
  begin
       Get;
                                               operation.DestinationType:=Copy(LexString,1,length(LexString)-1); 
       Expect(identSym);
                                               operation.DestinationFormat:=LexString; 
       if (CurrentInputSymbol=_commaSym) then
       begin
         Get;
         Expect(SQLStringSym);
                                               operation.DestinationOptions:=UnQuoteSQLString(LexString); 
       end;
       _CloseParens;
  end
  else if (CurrentInputSymbol=FILE_lparenSym) then
  begin
       Get;
                                               operation.DestinationType:=Copy(LexString,1,length(LexString)-1); 
       Expect(identSym);
                                               operation.DestinationFormat:=LexString; 
       Expect(_commaSym);
       Expect(SQLStringSym);
                                               operation.DestinationData:=UnQuoteSQLString(LexString); 
       if (CurrentInputSymbol=_commaSym) then
       begin
         Get;
         Expect(SQLStringSym);
                                               operation.DestinationOptions:=UnQuoteSQLString(LexString); 
       end;
       _CloseParens;
  end
  else SynError(13);
end;

procedure TkbmSQLParser._QualifiedTable(var table:TkbmSQLTable);
                                               var subset:string; 
begin
  _Table(table);
  if (CurrentInputSymbol in [FILE_lparenSym, TEXT_lparenSym]) then
  begin
    _Source(table);
  end;
  if (CurrentInputSymbol=SUBSETSym) then
  begin
    _SubSet(subset);
                                               table.SubSetExpression:=subset; 
  end;
  if (CurrentInputSymbol in [identSym, ASSym]) then
  begin
    if (CurrentInputSymbol=ASSym) then
    begin
      Get;
    end;
    Expect(identSym);
                                               table.Alias:=UnQuoteIdentifier(LexString); 
  end;
                                               FOperation.RefSourceTables.AddUnique(table); 
end;

procedure TkbmSQLParser._Table(var table:TkbmSQLTable);
begin
  Expect(identSym);
                                               table:=TkbmSQLTable.Create;
                                               table.Name:=UnQuoteIdentifier(LexString);
                                            
end;

procedure TkbmSQLParser._SubSet(var subset:string);
begin
  Expect(SUBSETSym);
  Expect(SQLStringSym);
                                               subset:=UnQuoteSQLString(LexString); 
end;

procedure TkbmSQLParser._Source(table:TkbmSQLTable);
begin
  if (CurrentInputSymbol=FILE_lparenSym) then
  begin
       Get;
  end
  else if (CurrentInputSymbol=TEXT_lparenSym) then
  begin
       Get;
  end
  else SynError(14);
                                               table.SourceType:=Copy(LexString,1,length(LexString)-1); 
  Expect(identSym);
                                               table.SourceFormat:=LexString; 
  Expect(_commaSym);
  Expect(SQLStringSym);
                                               table.SourceData:=UnQuoteSQLString(LexString); 
  if (CurrentInputSymbol=_commaSym) then
  begin
    Get;
    Expect(SQLStringSym);
                                               table.SourceOptions:=UnQuoteSQLString(LexString); 
  end;
  _CloseParens;
end;

procedure TkbmSQLParser._SearchCondition(var condition:TkbmSQLCustomNode);
begin
                                               condition:=nil;
                                               FOperation.ParseState:=sopsSearchCondition; 
  _Expression(condition);
                                               FOperation.ParseState:=sopsDefault; 
end;

procedure TkbmSQLParser._OrderByFldList(statement:TkbmSQLSelectOperation);
                                                      var node:TkbmSQLFieldNode; 
begin
  _OrderByField(node);
                                               statement.Order.Add(node);
                                               statement.RefSourceFields.Add(node);
                                            
  while (CurrentInputSymbol=_commaSym) do
  begin
    _ItemSeparator;
    _OrderByField(node);
                                               statement.Order.Add(node);
                                               statement.RefSourceFields.Add(node);
                                            
  end;
end;

procedure TkbmSQLParser._GroupByFldList(statement:TkbmSQLSelectOperation);
                                                      var node:TkbmSQLFieldNode; 
begin
  _GroupByField(node);
                                               statement.Group.Add(node);
                                               statement.RefSourceFields.Add(node);
                                            
  while (CurrentInputSymbol=_commaSym) do
  begin
    _ItemSeparator;
    _GroupByField(node);
                                               statement.Group.Add(node);
                                               statement.RefSourceFields.Add(node);
                                            
  end;
end;

procedure TkbmSQLParser._MathTerm(var node:TkbmSQLCustomNode);
                                                  var lnode,rnode:TkbmSQLCustomNode; 
begin
                                                  node:=nil;
                                                  lnode:=nil;
                                                  rnode:=nil;
                                               
  _Factor(lnode);
  while (CurrentInputSymbol in [_plusSym, _minusSym, _bar_barSym]) do
  begin
    if (CurrentInputSymbol=_plusSym) then
    begin
         Get;
         _Factor(rnode);
                                                   node:=AppendBinaryNode(FOperation,ebAdd,lnode,rnode);
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=_minusSym) then
    begin
         Get;
         _Factor(rnode);
                                                
                                                   node:=AppendBinaryNode(FOperation,ebSub,lnode,rnode);
                                                   rnode:=nil;
                                                   lnode:=node;
                                               
    end
    else if (CurrentInputSymbol=_bar_barSym) then
    begin
         Get;
         _Factor(rnode);
                                                   node:=AppendBinaryNode(FOperation,ebConcat,lnode,rnode);
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    ;
  end;
                                                  node:=lnode; 
end;

procedure TkbmSQLParser._SelectionExpr(var node:TkbmSQLCustomNode);
                                               var fld:TkbmSQLFieldNode; 
begin
                                               node:=nil;
                                               if LexString[1]='*' then
                                               begin
                                                    Get;
                                                    fld:=TkbmSQLFieldNode.Create(FOperation);
                                                    FOperation.RefSourceFields.Add(fld);
                                                    fld.FieldType:=ntWildCard;
                                                    fld.FieldName:='*';
                                                    fld.DataType:=ftBoolean; // Its not a boolean but its lowest priority.
                                                    node:=fld;
                                               end
                                               else
                                               begin
                                            
  _Expression(node);
  if (CurrentInputSymbol=ASSym) then
  begin
    Get;
    if (CurrentInputSymbol=identSym) then
    begin
         Get;
                                               node.Alias:=UnQuoteIdentifier(LexString); 
    end
    else if (CurrentInputSymbol=SQLStringSym) then
    begin
         Get;
                                               node.Alias:=UnQuoteSQLString(LexString); 
    end
    else SynError(15);
    if (CurrentInputSymbol=_lparenSym) then
    begin
      Get;
      Expect(SQLStringSym);
                                               node.Description:=UnQuoteSQLString(LexString); 
      Expect(_rparenSym);
    end;
  end;
                                               end; 
end;

procedure TkbmSQLParser._FunctionExpr(var exprnode:TkbmSQLCustomNode);
                                                  var nodes:TkbmSQLNodes;
                                                      aggnode:TkbmSQLAggregateNode;
                                                      sIdent:string;
                                               
begin
                                               exprnode:=nil;
                                               nodes:=TkbmSQLNodes.Create(true);
                                            
  Expect(funcidentSym);
                                               sIdent:=UpperCase(copy(LexString,1,length(LexString)-1));

                                               // Check if aggregate function.
                                               aggnode:=nil;
                                               if sIdent='COUNT' then
                                               begin
                                                    aggnode:=TkbmSQLAggregateNode.Create(FOperation);
                                                    aggnode.AggrFunction:=safCount;
                                               end
                                               else if sIdent='SUM' then
                                               begin
                                                    aggnode:=TkbmSQLAggregateNode.Create(FOperation);
                                                    aggnode.AggrFunction:=safSum;
                                               end
                                               else if sIdent='AVG' then
                                               begin
                                                    aggnode:=TkbmSQLAggregateNode.Create(FOperation);
                                                    aggnode.AggrFunction:=safAvg;
                                               end
                                               else if sIdent='STDDEV' then
                                               begin
                                                    aggnode:=TkbmSQLAggregateNode.Create(FOperation);
                                                    aggnode.AggrFunction:=safStdDev;
                                               end
                                               else if sIdent='MAX' then
                                               begin
                                                    aggnode:=TkbmSQLAggregateNode.Create(FOperation);
                                                    aggnode.AggrFunction:=safMax;
                                               end
                                               else if sIdent='MIN' then
                                               begin
                                                    aggnode:=TkbmSQLAggregateNode.Create(FOperation);
                                                    aggnode.AggrFunction:=safMin;
                                               end;
                                            
  if (CurrentInputSymbol=DISTINCTSym) then
  begin
    Get;
                                               if aggnode<>nil then
                                                  aggnode.Distinct:=true;
                                            
  end;
  if (CurrentInputSymbol=_rparenSym) then
  begin
       Get;
  end
  else if InSet(CurrentInputSymbol,2) then
  begin
       _ExpressionList(nodes);
       Expect(_rparenSym);
  end
  else SynError(16);
                                               if (aggnode=nil) or ((aggnode<>nil) and (nodes.Count>1)) then
                                               begin
                                                    if (aggnode<>nil) then
                                                        FreeAndNil(aggnode);
                                                    exprnode:=TkbmSQLFunctionNode.Create(FOperation,sIdent,nodes);
                                                    nodes.parent:=exprnode;
                                                    if not TkbmSQLFunctionNode(exprnode).IsFunctionValid then
                                                       SemError(215,TkbmSQLFunctionNode(exprnode).FunctionName);
                                               end
                                               else
                                               begin
                                                    try
                                                       if not (FOperation is TkbmSQLSelectOperation) then
                                                           raise Exception.Create('Aggregate functions only available in SELECT operations.');
                                                       if nodes.Count<>1 then
                                                           raise Exception.Create('Aggregate functions must contain one expression tree each.');
                                                       TkbmSQLSelectOperation(FOperation).Aggregates.Add(aggnode);
                                                       aggnode.ExpressionNode:=nodes[0];
                                                       aggnode.ExpressionNode.Parent:=aggnode;
                                                       nodes.delete(0); // Make sure its not freed in a moment.
                                                       exprnode:=aggnode;
                                                    finally
                                                       nodes.Free;
                                                    end;
                                               end;
                                            
end;

procedure TkbmSQLParser._ConstExpr(var node:TkbmSQLCustomNode);
begin
  if (CurrentInputSymbol=NULLSym) then
  begin
                                               node:=nil; 
       _Null;
                                               node:=TkbmSQLValueNode.Create(FOperation,evtNull);
                                               node.DataType:=ftUnknown;
                                            
  end
  else if (CurrentInputSymbol=TRUESym) then
  begin
       _True;
                                               node:=TkbmSQLConstNode.Create(FOperation,True);
                                               node.DataType:=ftBoolean;
                                            
  end
  else if (CurrentInputSymbol=FALSESym) then
  begin
       _False;
                                               node:=TkbmSQLConstNode.Create(FOperation,False);
                                               node.DataType:=ftBoolean;
                                            
  end
  else if (CurrentInputSymbol=floatSym) then
  begin
       Get;
                                               node:=TkbmSQLConstNode.Create(FOperation,kbmSQLStrToFloat(LexString));
                                               node.DataType:=ftFloat;
                                            
  end
  else if (CurrentInputSymbol=integer_Sym) then
  begin
       Get;
                                               node:=TkbmSQLConstNode.Create(FOperation,strtoint(LexString));
                                               node.DataType:=ftInteger;
                                            
  end
  else if (CurrentInputSymbol=SQLStringSym) then
  begin
       Get;
                                               node:=TkbmSQLConstNode.Create(FOperation,UnQuoteSQLString(LexString));
                                               node.DataType:=ftString;
                                            
  end
  else SynError(17);
end;

procedure TkbmSQLParser._Null;
begin
  Expect(NULLSym);
end;

procedure TkbmSQLParser._True;
begin
  Expect(TRUESym);
end;

procedure TkbmSQLParser._False;
begin
  Expect(FALSESym);
end;

procedure TkbmSQLParser._FieldExpr(var node:TkbmSQLCustomNode);
                                               var fieldnode:TkbmSQLFieldNode; 
begin
                                               node:=nil; 
  _QualifiedField(fieldnode);
                                              
                                               if FOperation.ParseState=sopsSelection then
                                                  FOperation.RefSourceFields.Add(fieldnode)
                                               else if FOperation.ParseState=sopsInsert then
                                                  FOperation.RefSourceFields.Add(fieldnode)
                                               else if FOperation.ParseState=sopsUpdate then
                                                  FOperation.RefSourceFields.Add(fieldnode)
                                               else if FOperation.ParseState=sopsFilter then
                                                  FOperation.RefSourceFields.Add(fieldnode)
                                               else if FOperation.ParseState=sopsSearchCondition then
                                               begin
                                                    FOperation.RefSearchFields.Add(fieldnode);
                                                    FOperation.RefSourceFields.Add(fieldnode);
                                               end
                                               else if FOperation.ParseState=sopsHavingCondition then
                                                    FOperation.RefHavingFields.Add(fieldnode);
                                               fieldnode.DataType:=ftBoolean; // Its not a boolean but its lowest priority.
                                               node:=fieldnode;
                                            
end;

procedure TkbmSQLParser._Variable(var node:TkbmSQLVariableNode);
begin
                                               node:=TkbmSQLVariableNode.Create(FOperation);
                                             
  Expect(variableidentSym);
                                               node.VariableName:=Copy(LexString,2,length(LexString));
                                               if not node.IsVariableValid then
                                                  SemError(214,node.VariableName);
                                            
end;

procedure TkbmSQLParser._SimpleVariable(var node:TkbmSQLVariableNode);
                                                  var s:string; 
begin
                                               node:=TkbmSQLVariableNode.Create(FOperation);
                                               s:='';
                                             
  Expect(identSym);
                                                s:=UnQuoteIdentifier(LexString); 
  while (CurrentInputSymbol=_pointSym) do
  begin
    Get;
    Expect(identSym);
                                                s:=s+'.'+UnQuoteIdentifier(LexString); 
  end;
                                                node.VariableName:=s;
                                                if not node.IsVariableValid then
                                                   SemError(214,node.VariableName);
                                             
end;

procedure TkbmSQLParser._VariableExpr(var node:TkbmSQLCustomNode);
                                                var varnode:TkbmSQLVariableNode; 
begin
                                                node:=nil; 
  _Variable(varnode);
                                                varnode.DataType:=ftBoolean; // Its not a boolean but its lowest priority.
                                                node:=varnode;
                                             
end;

procedure TkbmSQLParser._SimpleVariableExpr(var node:TkbmSQLCustomNode);
                                                      var varnode:TkbmSQLVariableNode; 
begin
                                                node:=nil; 
  _SimpleVariable(varnode);
                                                varnode.DataType:=ftBoolean; // Its not a boolean but its lowest priority.
                                                node:=varnode;
                                             
end;

procedure TkbmSQLParser._OrderByField(var node:TkbmSQLFieldNode);
begin
                                               node:=nil; 
  _QualifiedField(node);
                                               node.DataType:=ftUnknown;
                                               node.OrderBy:=true;
                                            
  if (CurrentInputSymbol in [DESCSym, ASCSym]) then
  begin
    if (CurrentInputSymbol=DESCSym) then
    begin
         Get;
                                               node.Descending:=true; 
    end
    else if (CurrentInputSymbol=ASCSym) then
    begin
         Get;
                                               node.Descending:=false; 
    end
    ;
  end;
end;

procedure TkbmSQLParser._GroupByField(var node:TkbmSQLFieldNode);
begin
                                               node:=nil; 
  _QualifiedField(node);
                                               node.DataType:=ftUnknown;
                                               node.GroupBy:=true;
                                            
end;

procedure TkbmSQLParser._AndOrTerm(var node:TkbmSQLCustomNode);
                                                   var lnode,rnode:TkbmSQLCustomNode; 
begin
                                                   node:=nil; lnode:=nil; rnode:=nil; 
  _BinaryExpression(lnode);
  while (CurrentInputSymbol in [ANDSym, ORSym, XORSym]) do
  begin
    if (CurrentInputSymbol=ANDSym) then
    begin
         Get;
         _Expression(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebAnd,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=ORSym) then
    begin
         Get;
         _Expression(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebOr,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=XORSym) then
    begin
         Get;
         _Expression(rnode);
                                                   
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebXor,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    ;
  end;
                                                   node:=lnode; 
end;

procedure TkbmSQLParser._BinaryExpression(var node:TkbmSQLCustomNode);
                                                   var lnode,rnode,l2node,r2node:TkbmSQLCustomNode;
                                                      bnot:boolean;
                                                      s:string;
                                                
begin
                                                   node:=nil;
                                                   rnode:=nil;
                                                   lnode:=nil;
                                                
  _MathTerm(lnode);
  while InSet(CurrentInputSymbol,3) do
  begin
    if (CurrentInputSymbol=_equalSym) then
    begin
         Get;
         _MathTerm(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebEqual,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=_less_greaterSym) then
    begin
         Get;
         _MathTerm(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebNotEqual,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=_lessSym) then
    begin
         Get;
         _MathTerm(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebLess,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=_less_equalSym) then
    begin
         Get;
         _MathTerm(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebLessEqual,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=_greaterSym) then
    begin
         Get;
         _MathTerm(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebGreater,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=_greater_equalSym) then
    begin
         Get;
         _MathTerm(rnode);
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=AppendBinaryNode(FOperation,ebGreaterEqual,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=INSym) then
    begin
         Get;
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=TkbmSQLInNode.Create(FOperation);
                                                   TkbmSQLInNode(node).LeftNode:=lnode;
                                                   TkbmSQLInNode(node).LeftNode.Parent:=node;
                                                   node.DataType:=ftBoolean;
                                                   lnode:=node;
                                                
         _OpenParens;
         _ExpressionList(TkbmSQLInNode(node).Nodes);
         _CloseParens;
    end
    else if (CurrentInputSymbol=LIKESym) then
    begin
         Get;
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=TkbmSQLBinaryNode.Create(FOperation,ebLike);
                                                   TkbmSQLBinaryNode(node).LeftNode:=lnode;
                                                   TkbmSQLBinaryNode(node).LeftNode.Parent:=node;
                                                   node.DataType:=ftBoolean;
                                                   lnode:=node;
                                                
         Expect(SQLStringSym);
                                                  
                                                   s:=UnQuoteSQLString(LexString);
                                                   TkbmSQLBinaryNode(node).RightNode:=TkbmSQLConstNode.Create(FOperation,s);
                                                   TkbmSQLBinaryNode(node).RightNode.Parent:=node;
                                                
    end
    else if (CurrentInputSymbol=BETWEENSym) then
    begin
         Get;
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   node:=TkbmSQLBetweenNode.Create(FOperation);
                                                   TkbmSQLBetweenNode(node).LeftNode:=lnode;
                                                   TkbmSQLBetweenNode(node).LeftNode.Parent:=node;
                                                   node.DataType:=ftBoolean;
                                                   lnode:=node;
                                                
         _MathTerm(l2node);
                                                   TkbmSQLBetweenNode(node).RangeLow:=l2node;
                                                   if l2node<>nil then
                                                      TkbmSQLBetweenNode(node).RangeLow.Parent:=node;
                                                   l2node:=nil;
                                                
         Expect(ANDSym);
         _MathTerm(r2node);
                                                   TkbmSQLBetweenNode(node).RangeHigh:=r2node;
                                                   if r2node<>nil then
                                                      TkbmSQLBetweenNode(node).RangeHigh.Parent:=node;
                                                   r2node:=nil;
                                                
    end
    else if (CurrentInputSymbol=ISSym) then
    begin
         Get;
                                                   bnot:=false; 
         if (CurrentInputSymbol=NOTSym) then
         begin
           Get;
                                                   bnot:=true; 
         end;
         if (CurrentInputSymbol=NULLSym) then
         begin
              _Null;
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   rnode:=TkbmSQLValueNode.Create(FOperation,evtNull);
                                                   rnode.DataType:=ftBoolean;
                                                
         end
         else if (CurrentInputSymbol=TRUESym) then
         begin
              _True;
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   rnode:=TkbmSQLConstNode.Create(FOperation,true);
                                                   rnode.DataType:=ftBoolean;
                                                
         end
         else if (CurrentInputSymbol=FALSESym) then
         begin
              _False;
                                                  
                                                   if sopfNoBooleanExpressions in FOperation.Flags then
                                                      SynError(213);
                                                   rnode:=TkbmSQLConstNode.Create(FOperation,false);
                                                   rnode.DataType:=ftBoolean;
                                                
         end
         else SynError(18);
                                                   if bnot then
                                                      node:=AppendBinaryNode(FOperation,ebNotEqual,lnode,rnode)
                                                   else
                                                      node:=AppendBinaryNode(FOperation,ebEqual,lnode,rnode);
                                                   node.DataType:=ftBoolean;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    ;
  end;
                                                   node:=lnode; 
end;

procedure TkbmSQLParser._Factor(var node:TkbmSQLCustomNode);
                                                  var lnode,rnode:TkbmSQLCustomNode; 
begin
                                                  node:=nil;
                                                  rnode:=nil;
                                                  lnode:=nil;
                                               
  _Term(lnode);
  while InSet(CurrentInputSymbol,4) do
  begin
    if (CurrentInputSymbol=_starSym) then
    begin
         Get;
         _Term(rnode);
                                                   node:=AppendBinaryNode(FOperation,ebMul,lnode,rnode);
                                                   if node<>nil then
                                                      node.DataType:=ftUnknown; // Will be determined later.
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=_slashSym) then
    begin
         Get;
         _Term(rnode);
                                                   node:=AppendBinaryNode(FOperation,ebDiv,lnode,rnode);
                                                   if node<>nil then
                                                      node.DataType:=ftFloat;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    else if (CurrentInputSymbol=MODSym) then
    begin
         Get;
         _Term(rnode);
                                                   node:=AppendBinaryNode(FOperation,ebMod,lnode,rnode);
                                                   if node<>nil then
                                                      node.DataType:=ftInteger;
                                                   rnode:=nil;
                                                   lnode:=node;
                                               
    end
    else if (CurrentInputSymbol=DIVSym) then
    begin
         Get;
         _Term(rnode);
                                                   node:=AppendBinaryNode(FOperation,ebIDiv,lnode,rnode);
                                                   if node<>nil then
                                                      node.DataType:=ftInteger;
                                                   rnode:=nil;
                                                   lnode:=node;
                                                
    end
    ;
  end;
                                                  node:=lnode; 
end;

procedure TkbmSQLParser._Term(var node:TkbmSQLCustomNode);
                                                  var nnode:TkbmSQLCustomNode; 
begin
  if InSet(CurrentInputSymbol,5) then
  begin
                                                  node:=nil;
                                                  nnode:=nil;
                                               
       if (CurrentInputSymbol=_minusSym) then
       begin
         Get;
                                                  nnode:=TkbmSQLUnaryNode.Create(FOperation,euNegate); 
       end;
       if InSet(CurrentInputSymbol,6) then
       begin
            if (CurrentInputSymbol=funcidentSym) then
            begin
                 _FunctionExpr(node);
            end
            else if (CurrentInputSymbol in [identSym, _starSym]) and ( FOperation.ParseState<>sopsEvaluation ) then
            begin
                 _FieldExpr(node);
            end
            else if (CurrentInputSymbol=identSym) and ( FOperation.ParseState=sopsEvaluation ) then
            begin
                 _SimpleVariableExpr(node);
            end
            else if (CurrentInputSymbol=variableidentSym) then
            begin
                 _VariableExpr(node);
            end
            else if InSet(CurrentInputSymbol,7) then
            begin
                 _ConstExpr(node);
            end
            ;
       end
       else if (CurrentInputSymbol=_lparenSym) then
       begin
            _OpenParens;
            _Expression(node);
            _CloseParens;
       end
       else SynError(19);
                                                  
                                                  if nnode<>nil then
                                                  begin
                                                       nnode.DataType:=ftBoolean; // Its not a boolean but its lowest priority.
                                                       if node<>nil then
                                                       begin
                                                            TkbmSQLUnaryNode(nnode).RightNode:=node;
                                                            TkbmSQLUnaryNode(nnode).RightNode.Parent:=nnode;
                                                       end;
                                                       node:=nnode;
                                                  end;
                                               
  end
  else if InSet(CurrentInputSymbol,8) then
  begin
       Get;
                                                  SynError(201); 
  end
  else SynError(19);
end;



function TkbmSQLParser.TokenToString(n: Integer): String;
const TokenStrings: array[0.._NOSYMB] of String = ('EOF'
	,'SQLString'	,'variableident'	,'ident'	,'funcident'	,'integer_'
	,'float'	,'";"'	,'"UNION"'	,'"ALL"'	,'"UPDATE"'
	,'"SET"'	,'"="'	,'"INSERT"'	,'"INTO"'	,'"VALUES"'
	,'"DELETE"'	,'"FROM"'	,'"EVAL"'	,'"CALC"'	,'"FILTER"'
	,'"SELECT"'	,'"DISTINCT"'	,'"OUTPUT"'	,'"AS"'	,'"SUBSET"'
	,'"WHERE"'	,'"HAVING"'	,'"ORDER"'	,'"BY"'	,'"GROUP"'
	,'"LIMIT"'	,'"OFFSET"'	,'"("'	,'")"'	,'"*"'
	,'"."'	,'"NULL"'	,'"TRUE"'	,'"FALSE"'	,'"FILE("'
	,'"TEXT("'	,'","'	,'"DESC"'	,'"ASC"'	,'"NOT"'
	,'"AND"'	,'"OR"'	,'"XOR"'	,'"<>"'	,'"<"'
	,'"<="'	,'">"'	,'">="'	,'"IN"'	,'"LIKE"'
	,'"BETWEEN"'	,'"IS"'	,'"+"'	,'"-"'	,'"||"'
	,'"/"'	,'"MOD"'	,'"DIV"'  ,'not');
begin
  if n in [0.._NOSYMB] then
    Result := TokenStrings[n]
  else Result := '?';
end;

function TkbmSQLParser.ErrorMessage(ErrorType, ErrorCode: Integer; const data: string): String;
begin
  case ErrorCode of
	1 : Result := 'invalid kbmSQLParser';
	2 : Result := 'invalid Evaluate';
	3 : Result := 'invalid EvaluateStmt';
	4 : Result := 'this symbol not expected in WhereClause';
	5 : Result := 'invalid QualifiedField';
	6 : Result := 'this symbol not expected in FromClause';
	7 : Result := 'this symbol not expected in GroupByClause';
	8 : Result := 'this symbol not expected in HavingClause';
	9 : Result := 'this symbol not expected in OrderByClause';
	10 : Result := 'this symbol not expected in LimitClause';
	11 : Result := 'this symbol not expected in OffsetClause';
	12 : Result := 'this symbol not expected in OutputClause';
	13 : Result := 'invalid Destination';
	14 : Result := 'invalid Source';
	15 : Result := 'invalid SelectionExpr';
	16 : Result := 'invalid FunctionExpr';
	17 : Result := 'invalid ConstExpr';
	18 : Result := 'invalid BinaryExpression';
	19 : Result := 'invalid Term';

              
    200 : Result := 'Missing SQL statement';
    201 : Result := 'Invalid input';
    210 : Result := '"ON" or "USING" clause may not be used with "NATURAL"';
    211 : Result := '"UNION JOIN" not supported';
    212 : Result := '"NULL" keyword cannot be used here - use "IS" or "IS NOT"';
    213 : Result := 'Conditionals not allowed in expression';
    214 : Result := 'Unknown variable';
    215 : Result := 'Unknown function';
    216 : Result := 'Only numeric expressions allowed';

    else Result := inherited ErrorMessage(ErrorType, ErrorCode,data);
  end;
end;


procedure TkbmSQLParser.ProcessPragmas;
begin

end;


function TkbmSQLParser.Execute: Boolean;
begin
  Reinit;
  _kbmSQLParser;
  Result := Successful;
end;


function TkbmSQLParser.CreateScanner: TBaseScanner;
begin
  Result := TkbmSQLParserScanner.Create(Self);
  if kbmSQLParserST=nil then
  begin
    kbmSQLParserST := TStartTable.Create;
    with kbmSQLParserST do
    begin
	  FillRange(65, 90, 11);  States[95] := 11;  FillRange(97, 122, 11);  FillRange(48, 57, 12);
	  States[39] := 1;  States[34] := 2;  States[36] := 3;  States[91] := 5;  States[46] := 29;
	  States[47] := 30;  States[59] := 16;  States[61] := 17;  States[40] := 18;  States[41] := 19;
	  States[42] := 20;  States[44] := 21;  States[60] := 31;  States[62] := 32;  States[43] := 25;
	  States[45] := 26;  States[124] := 27;
    end;
    kbmSQLParserLiterals := CreateLiterals(False,
	['UNION','ALL','UPDATE','SET','INSERT','INTO','VALUES','DELETE','FROM','EVAL','CALC','FILTER','SELECT','DISTINCT','OUTPUT'
		,'AS','SUBSET','WHERE','HAVING','ORDER','BY','GROUP','LIMIT','OFFSET','NULL','TRUE','FALSE','FILE(','TEXT(','DESC','ASC'
		,'NOT','AND','OR','XOR','IN','LIKE','BETWEEN','IS','MOD','DIV'],
	[UNIONSym,ALLSym,UPDATESym,SETSym,INSERTSym,INTOSym,VALUESSym,DELETESym,FROMSym,EVALSym,CALCSym,FILTERSym,SELECTSym
		,DISTINCTSym,OUTPUTSym,ASSym,SUBSETSym,WHERESym,HAVINGSym,ORDERSym,BYSym,GROUPSym,LIMITSym,OFFSETSym,NULLSym,TRUESym
		,FALSESym,FILE_lparenSym,TEXT_lparenSym,DESCSym,ASCSym,NOTSym,ANDSym,ORSym,XORSym,INSym,LIKESym,BETWEENSym,ISSym,MODSym
		,DIVSym]
     );
  end;
  with TkbmSQLParserScanner(Result) do
  begin
    CaseInsensitive := True;  
    noSym := _NOSYMB;
    StartState := kbmSQLParserST;
    Literals := kbmSQLParserLiterals;
  end;
end;


constructor TkbmSQLParser.Create(AOwner: TComponent);
begin
  
  inherited;

  if Length(kbmSQLParserSymSets)=0 then
  InitSymSets(kbmSQLParserSymSets,[
    	{ 0} _EOFSYMB, SQLStringSym, variableidentSym, identSym, funcidentSym, integer_Sym, floatSym, _semicolonSym, UNIONSym, ALLSym, UPDATESym, SETSym, _equalSym, INSERTSym, INTOSym, VALUESSym, DELETESym, FROMSym, EVALSym, CALCSym, FILTERSym, SELECTSym, DISTINCTSym, OUTPUTSym, ASSym, SUBSETSym, WHERESym, HAVINGSym, ORDERSym, BYSym, GROUPSym, LIMITSym, OFFSETSym, _lparenSym, _rparenSym, _starSym, _pointSym, NULLSym, TRUESym, FALSESym, FILE_lparenSym, TEXT_lparenSym, _commaSym, DESCSym, ASCSym, NOTSym, ANDSym, ORSym, XORSym, _less_greaterSym, _lessSym, _less_equalSym, _greaterSym, _greater_equalSym, INSym, LIKESym, 
BETWEENSym, ISSym, _plusSym, _minusSym, _bar_barSym, _slashSym, MODSym, DIVSym, _NOSYMB, -1,
	{ 1} _EOFSYMB, identSym, _semicolonSym, UNIONSym, _equalSym, VALUESSym, FROMSym, OUTPUTSym, ASSym, SUBSETSym, WHERESym, HAVINGSym, ORDERSym, GROUPSym, LIMITSym, OFFSETSym, _rparenSym, _starSym, _commaSym, ANDSym, ORSym, XORSym, _less_greaterSym, _lessSym, _less_equalSym, _greaterSym, _greater_equalSym, INSym, LIKESym, BETWEENSym, ISSym, _plusSym, _minusSym, _bar_barSym, _slashSym, MODSym, DIVSym, -1,
	{ 2} SQLStringSym, variableidentSym, identSym, funcidentSym, integer_Sym, floatSym, _semicolonSym, UNIONSym, ALLSym, UPDATESym, SETSym, _equalSym, INSERTSym, INTOSym, VALUESSym, DELETESym, FROMSym, EVALSym, CALCSym, FILTERSym, SELECTSym, DISTINCTSym, OUTPUTSym, ASSym, SUBSETSym, WHERESym, HAVINGSym, ORDERSym, BYSym, GROUPSym, LIMITSym, OFFSETSym, _lparenSym, _rparenSym, _starSym, _pointSym, NULLSym, TRUESym, FALSESym, FILE_lparenSym, TEXT_lparenSym, _commaSym, DESCSym, ASCSym, NOTSym, ANDSym, ORSym, XORSym, _less_greaterSym, _lessSym, _less_equalSym, _greaterSym, _greater_equalSym, INSym, LIKESym, BETWEENSym, 
ISSym, _plusSym, _minusSym, _bar_barSym, _slashSym, MODSym, DIVSym, _NOSYMB, -1,
	{ 3} _equalSym, _less_greaterSym, _lessSym, _less_equalSym, _greaterSym, _greater_equalSym, INSym, LIKESym, BETWEENSym, ISSym, -1,
	{ 4} _starSym, _slashSym, MODSym, DIVSym, -1,
	{ 5} SQLStringSym, variableidentSym, identSym, funcidentSym, integer_Sym, floatSym, _lparenSym, _starSym, NULLSym, TRUESym, FALSESym, _minusSym, -1,
	{ 6} SQLStringSym, variableidentSym, identSym, funcidentSym, integer_Sym, floatSym, _starSym, NULLSym, TRUESym, FALSESym, -1,
	{ 7} SQLStringSym, integer_Sym, floatSym, NULLSym, TRUESym, FALSESym, -1,
	{ 8} ALLSym, UPDATESym, SETSym, INSERTSym, INTOSym, VALUESSym, DELETESym, EVALSym, CALCSym, FILTERSym, SELECTSym, DISTINCTSym, SUBSETSym, BYSym, _pointSym, FILE_lparenSym, TEXT_lparenSym, DESCSym, ASCSym, NOTSym, _NOSYMB
  ]); 
  SymSets := kbmSQLParserSymSets;
           
    FOperation:=nil;
    FContext:=nil;
    FOnGetVariableMetaData:=nil;
    FOnGetVariableValue:=nil;
    FOnGetFunction:=nil;
{$IFDEF LEVEL9}
    self.FormatSettings.DecimalSeparator:='.';
{$ENDIF}
  
end;

destructor TkbmSQLParser.Destroy;
begin
            
    FOperation.Free;

  inherited;

end;

end.
